# Paste your code for both WeightedEdge and WeightedDigraph in this box.
# You may assume the grader has provided implementations for Node, Edge, and Digraph.
class WeightedEdge(Edge):
    def __init__(self, src, dest, total_distance, outdoors_distance):
        Edge.__init__(self, src, dest)
        self.total_distance = total_distance
        self.outdoors_distance = outdoors_distance

    def __str__(self):
        return Edge.__str__(self) + " (" + str(self.getTotalDistance()) + ", " + str(self.getOutdoorDistance()) + ")"

    def getTotalDistance(self):
        return self.total_distance

    def getOutdoorDistance(self):
        return self.outdoors_distance

class WeightedDigraph(Digraph):
    def __init__(self):
        Digraph.__init__(self)

    def addEdge(self, edge):
        src = edge.getSource()
        dest = edge.getDestination()
        # float to make it look like the test case
        total_distance = float(edge.getTotalDistance())
        outdoor_distance = float(edge.getOutdoorDistance())

        if not(src in self.nodes and dest in self.nodes):
            raise ValueError('Node not in graph')
        self.edges[src].append([dest, (total_distance, outdoor_distance)])

    def childrenOf(self, node):
        res = []
        for d in self.edges[node]:
            res.append(d[0])
        return res

    def edgeWeight(self, start, end):
        for d in self.edges[start]:
            if d[0] == end:
                return d[1]
        raise ValueError('Edge not in graph')

    def __str__(self):
        res = ''
        for k in self.edges:
            for d in self.edges[k]:
                res = '{0}{1}->{2} {3}\n'.format(res, k, d[0], d[1])
        return res[:-1]

# Additionally paste your code for bruteForceSearch, and any helper functions, in this box.
def bruteForceSearch(digraph, start, end, maxTotalDist, maxDistOutdoors):    
    """
    Finds the shortest path from start to end using brute-force approach.
    The total distance travelled on the path must not exceed maxTotalDist, and
    the distance spent outdoor on this path must not exceed maxDistOutdoors.

    Parameters: 
        digraph: instance of class Digraph or its subclass
        start, end: start & end building numbers (strings)
        maxTotalDist : maximum total distance on a path (integer)
        maxDistOutdoors: maximum distance spent outdoors on a path (integer)

    Assumes:
        start and end are numbers for existing buildings in graph

    Returns:
        The shortest-path from start to end, represented by 
        a list of building numbers (in strings), [n_1, n_2, ..., n_k], 
        where there exists an edge from n_i to n_(i+1) in digraph, 
        for all 1 <= i < k.

        If there exists no path that satisfies maxTotalDist and
        maxDistOutdoors constraints, then raises a ValueError.
    """
    #TODO
    all_valid_path = get_all_valid_path(digraph, start, end)
    shortest_path = []
    shortest_dist = float('inf')
    for path in all_valid_path:
        total_dist = 0
        outdoor_dist = 0
        for index, n in enumerate(path[:-1]):
            for dest, (total, outdoor) in digraph.edges[Node(n)]:
                if str(dest) == path[index+1]:
                    total_dist += total
                    outdoor_dist += outdoor
                    break
        if (total_dist <= maxTotalDist) & (outdoor_dist <= maxDistOutdoors) & (total_dist <= shortest_dist):
            shortest_path = path
            shortest_dist = total_dist
    if not shortest_path:
        raise ValueError
    return shortest_path
    
def get_all_valid_path(digraph, start, end):
    '''
    use depth-first to find all valid path
    find all possible path from start, parent > children,
    if chidren of node is end, add to valid_path, delete from queue
    if all children of node is already in path, delete from queue
    '''
    queue = []
    valid_path = []
    queue.append([start])
    while queue:
        current_path = queue.pop(-1)
        if current_path[-1] == end:
            valid_path.append(current_path)
        current_node = current_path[-1]
        current_children = digraph.childrenOf(Node(current_node))
        for node in current_children:
            if str(node) not in current_path: #avoid cycles
                newpath = current_path + [str(node)]
                queue.append(newpath)
    return valid_path
